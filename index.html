<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Split-and-Conquer: Client-Decoupled Split Federated Learning in Heterogeneous Environments</title>
  <style>
    /* Ensure identical font rendering across Canvas & GitHub Pages */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
    :root{
      --bg:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --line: rgba(15,23,42,.12);
      --soft:#f6f7fb;
      --soft2:#fbfbfd;
      --shadow: 0 10px 25px rgba(15,23,42,.08);
      --radius: 14px;
      --max: 980px;

      /* New paper color palette */
      --teal:#007F8F;
      --green:#008000;
      --accentTitle:#007F8F;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height:1.65;
    }
    a{color:inherit}

    .wrap{max-width:var(--max); margin:46px auto 88px; padding:0 18px}

    /* Header */
    header{padding-bottom:16px; border-bottom:1px solid var(--line)}
    h1{
      margin:0;
      text-align:center;
      font-size:clamp(2.2rem, 4.2vw, 3.1rem);
      line-height:1.15;
      letter-spacing:-0.02em;
      font-weight:900;
    }
    h1 .brand{color:var(--teal)}    .authors{margin:8px 0 0; text-align:center; color:var(--muted); font-weight:600}
    /* Buttons */
    .btnrow{display:flex; justify-content:center; flex-wrap:wrap; gap:10px; margin:18px 0 0}
    .btn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--soft2);
      font-weight:800;
      text-decoration:none;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
      box-shadow: 0 6px 16px rgba(15,23,42,.06);
    }
    .btn:hover{transform: translateY(-1px); box-shadow: 0 10px 25px rgba(15,23,42,.10); border-color: rgba(15,23,42,.18)}
    .btn.primary{border-color: rgba(0,127,143,.35)}
    .btn.secondary{border-color: rgba(0,128,0,.35)}
    .icon{width:18px; height:18px; display:inline-block}

    /* Content */
    main{margin-top:28px}
    section{margin: 0 0 34px}
    h2{
      margin:0 0 18px;
      text-align:center;
      font-size:1.7rem;
      letter-spacing:-0.01em;
      color:var(--accentTitle);
      font-weight:900;
      position:relative;
    }
    h2::after{
      content:"";
      display:block;
      width:64px;
      height:4px;
      margin:12px auto 0;
      background:linear-gradient(90deg, var(--teal), var(--green));
      border-radius:999px;
    }
    h3{margin:18px 0 8px; font-size:1.05rem}
    p{margin:0 0 12px}
    .muted{color:var(--muted)}

    /* Figures */
    figure{
      margin:14px 0 0;
      padding:12px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--soft);
      box-shadow: var(--shadow);
    }
    figure .frame{
      background:#fff;
      border:1px solid rgba(15,23,42,.10);
      border-radius: 12px;
      padding:0;              /* remove extra left/right whitespace */
      overflow:hidden;
    }
    figure img{
      display:block;
      width:100%;
      height:auto;
      margin:0;
    }
    figcaption{margin-top:10px; color:var(--muted); font-size:.95rem}

    /* Unified figure sizing */
    .side-figure{
      max-width:560px;     /* requested */
      margin-left:auto;
      margin-right:auto;
    }

    /* Overall workflow: about half-size and centered */
    .workflow-figure{
      max-width:1000px;     /* keep consistent container */
      margin-left:auto;
      margin-right:auto;
    }
    .workflow-figure img{
      width:100%;           /* ~half size within the figure frame */
      margin-left:auto;
      margin-right:auto;
    }

    /* Callouts */
    .callout{
      border:1px solid rgba(0,127,143,.25);
      background: linear-gradient(180deg, rgba(0,127,143,.10), rgba(0,128,0,.08));
      border-radius: var(--radius);
      padding:14px;
    }

    /* BibTeX */
    pre{
      margin:0;
      padding:14px;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: var(--soft);
      overflow:auto;
      font-size:.95rem;
      line-height:1.45;
    }
    ul{margin:8px 0 0; padding-left:18px}
    li{margin:6px 0}

    /* Section separator */
    .sep{border:none; border-top:1px solid var(--line); margin:42px 0}

    /* Two-column layout for results/motivation */
    .twocol{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap:22px;
      align-items:start;
    }
    @media (max-width: 900px){
      .twocol{grid-template-columns:1fr}
      .workflow-figure img{width:100%}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1><span class="brand">Split-and-Conquer</span>: Client-Decoupled Split Federated Learning in Heterogeneous Environments</h1>
      <div class="authors">Anonymous Authors</div>
      

      <nav class="btnrow" aria-label="Project links">
        <a class="btn primary" href="#" target="_blank" rel="noopener">
          <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M7 4h10a2 2 0 0 1 2 2v14l-4-2-4 2-4-2-4 2V6a2 2 0 0 1 2-2Z" stroke="currentColor" stroke-width="2"/>
          </svg>
          Paper
        </a>
        <a class="btn secondary" href="https://anonymous.4open.science/r/Split-and-Conquer_llamafactory-E023/README.md" target="_blank" rel="noopener">
          <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M9 19c-1.66 0-3-1.34-3-3V8c0-1.66 1.34-3 3-3h7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <path d="M15 5h2a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3h-2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
          Code
        </a>
      </nav>
    </header>

    <main>
      <!-- ===== Overview ===== -->
      <section>
        <h2>Overview</h2>
        <p class="muted">
          <strong>Split-and-Conquer</strong> is a Split Federated Learning (SFL) framework designed for <em>heterogeneous</em> environments.
          It removes strict client–server backpropagation dependency so clients can personalize locally and the server can train robustly under stragglers.
        </p>

        <div class="callout">
          <ul class="muted" style="margin:0;">
            <li><strong>Client personalization:</strong> client-side layers are fully personalized; only a lightweight <em>shared head</em> is federated.</li>
            <li><strong>Client decoupling:</strong> clients compute loss &amp; update without waiting for server gradients.</li>
            <li><strong>Straggler robustness:</strong> server trains asynchronously using a replay buffer of client embeddings.</li>
          </ul>
        </div>

        <figure class="workflow-figure">
          <div class="frame">
            <!-- Upload to: assets/figures/figure2.png -->
            <img src="assets/figures/figure2.png" alt="Overall workflow of Split-and-Conquer" />
          </div>
          <figcaption><strong>Figure 1.</strong> Overall workflow of Split-and-Conquer.</figcaption>
        </figure>
      </section>

      <hr class="sep" />

      <!-- ===== Abstract ===== -->
      <section>
        <h2>Abstract</h2>
        <p class="muted">
          Split Federated Learning (SFL) enables collaborative training of large models under privacy and resource constraints,
          but existing methods tightly couple client updates with server-side backpropagation.
          This coupling prevents client-specific personalization under heterogeneous environments and leads to severe training delays with stragglers.
          Split-and-Conquer decouples client-side personalization from server-side representation learning with a lightweight shared head (federated component)
          and a server-side replay buffer for asynchronous, straggler-robust server training.
        </p>
      </section>

      <hr class="sep" />

      <!-- ===== Motivation ===== -->
      <section>
        <h2>Motivation</h2>
        <div class="twocol">
          <div>
            <p class="muted">Existing SFL methods suffer from two practical bottlenecks in real deployments:</p>
            <ul class="muted">
              <li><strong>Weak personalization:</strong> federated aggregation on client-side layers enforces shared representations, hurting performance under non-IID data and heterogeneous devices.</li>
              <li><strong>Straggler delays:</strong> clients must wait for server-side backpropagation, so slow clients delay end-to-end progress.</li>
            </ul>
            <p class="muted" style="margin-top:10px;">
              The core question: <strong>Can we redesign SFL to enable client-specific personalization and straggler-robust training efficiency at the same time?</strong>
            </p>
          </div>

          <figure class="side-figure" style="margin-top:0">
            <div class="frame">
              <!-- Upload to: assets/figures/figure1.png -->
              <img src="assets/figures/figure1.png" alt="Accuracy and training-time efficiency teaser" />
            </div>
            <figcaption><strong>Figure 2.</strong> Accuracy and training-time efficiency teaser.</figcaption>
          </figure>
        </div>
      </section>

      <hr class="sep" />

      <!-- ===== Method ===== -->
      <section>
        <h2>Method: Split-and-Conquer</h2>
        <p class="muted">
          We split training into two parallel processes:
          (1) <strong>client-side personalization</strong> (fully local updates) and
          (2) <strong>server-side representation learning</strong> (asynchronous updates using replay).
          The only federated component is a <strong>lightweight shared head</strong>.
        </p>

        <h3>What’s new?</h3>
        <ul class="muted">
          <li><strong>Compatibility-aware client update:</strong> before training the full local model, each client first updates only the personalized layers while freezing the aggregated shared head.</li>
          <li><strong>Asynchronous server training:</strong> clients send latent embeddings; the server stores them in a replay memory and trains a large server-side model independent of client availability.</li>
          <li><strong>Decoupled critical path:</strong> removing server-to-client backpropagation lets client updates and server updates run in parallel.</li>
        </ul>
      </section>

      <hr class="sep" />

      <!-- ===== Results ===== -->
      <section>
        <h2>Results</h2>
        <p class="muted">
          Split-and-Conquer delivers <strong>better accuracy under heterogeneity</strong> while improving <strong>end-to-end training efficiency</strong> under stragglers.
          Below are two headline results.
        </p>

        <div class="twocol" style="margin-top:14px">
          <div>
            <h3>Straggler-robust training efficiency</h3>
            <p class="muted">
              As the straggler ratio increases, conventional split FL approaches slow down due to synchronized client–server backpropagation.
              Split-and-Conquer decouples the critical path, keeping round time stable and improving normalized training-time efficiency.
            </p>
            <ul class="muted">
              <li><strong>Metric:</strong> end-to-end round time &amp; normalized training-time efficiency</li>
              <li><strong>Setting:</strong> varying straggler ratio (e.g., 0–50%)</li>
              <li><strong>Takeaway:</strong> robust efficiency even with many slow clients</li>
            </ul>
          </div>

          <figure class="side-figure" style="margin-top:0">
            <div class="frame">
              <!-- Upload to: assets/figures/figure3.png -->
              <img src="assets/figures/figure3.png" alt="Training time efficiency under stragglers" />
            </div>
            <figcaption><strong>Figure 3.</strong> Straggler-robust efficiency: end-to-end round time and normalized training-time efficiency as straggler ratio increases.</figcaption>
          </figure>
        </div>

        <div class="twocol" style="margin-top:18px">
          <div>
            <h3>Ablations: why it works</h3>
            <p class="muted">
              We ablate three components to show what drives performance and stability:
              server capacity, replay memory size, and the compatibility step (freezing the shared head) that prevents mismatch during client personalization.
            </p>
            <ul class="muted">
              <li><strong>Server capacity:</strong> larger server models improve representation learning</li>
              <li><strong>Replay memory:</strong> more replay stabilizes learning under partial participation</li>
              <li><strong>Compatibility step:</strong> freezing the aggregated head improves robustness</li>
            </ul>
          </div>

          <figure class="side-figure" style="margin-top:0">
            <div class="frame">
              <!-- Upload to: assets/figures/figure4.png -->
              <img src="assets/figures/figure4.png" alt="Ablation studies" />
            </div>
            <figcaption><strong>Figure 4.</strong> Ablations: (a) server capacity, (b) replay memory size, (c) freezing shared head for compatibility.</figcaption>
          </figure>
        </div>
      </section>

      <!-- ===== BibTeX (commented out for anonymous submission) =====
      <section>
        <h2>BibTeX</h2>
        <pre>@inproceedings{anonymous2026split,
  title={Split-and-Conquer: Client-Decoupled Split Federated Learning in Heterogeneous Environments},
  author={Anonymous Authors},
  year={2026}
}</pre>
      </section>
      -->

      
    </main>
  </div>
</body>
</html>
